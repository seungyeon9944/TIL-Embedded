## Navigation
로봇에서의 네비게이션 : 목적지까지의 경로를 탐색하고 도착 (**위치, 센싱, 지도, 경로**)

스마트홈에서 사용할 터틀봇 로봇 : 라이다, IMU, 카메라, 모터 2개 가지고 있음

### 1. Mapping
- **2D 라이다 센서를 이용해 주변 환경에 대한 맵**을 만듦
- Mapping 과정
    - 로봇을 움직이고, 움직인 **거리를 추정하고, 이전 위치와 누적해서 현재 위치 계산**
    - 현재 위치에서 들어오는 센서 데이터를 이전에 저장한 센서데이터와 합침
    - 맵을 만들고 싶은 공간을 모두 돌아다니면서 위 과정 반복

### 2. Localization
- 맵에 **로봇의 위치를 표시**하는 것
- Localization 과정
    - 1. 맵을 읽어온다
    - 2. 초기 위치를 설정한다
    - 3. 로봇을 이동시키면서 움직인 거리를 추정하고, 이전 위치와 누적해서 현재 위치를 계산한다
    - 4. **예측한 현재 위치에서 들어올 라이다 데이터와 현재 들어오고 있는 라이다 데이터를 비교**한다
    - 5. 예측한 현재 위치를 확정한다
    - 6. 위 과정을 반복한다

### 3. Path Planning
- Path는 **로봇이 존재할 수 있는 위치의 집합**으로 표현하는 방법에는 점으로 표현하는 방법과 그리드로 표현하는 방법이 있음
- Path Planning은 **경로를 만드는 과정**
    - 데이터를 활용해 경로를 만드는 법 (동적) → 원하는 목적지를 선택하면 경로가 만들어짐
    - 직접주행을 통해 경로를 만드는 법 (정적) → 출발지, 목적지가 항상 같다

### 4. Sensing
- **장애물 인지센서(카메라, 라이다, 초음파, 적외선)** 이용해 장애물을 인지

### Odometry
- 로봇이 **움직인 이동량을 추정해서 누적**한 것
- 이동량은 로봇의 속도를 이용해 구함
- 로봇의 속도는 두가지로 이루어져있음
    - 선속도 : 이동하려는 선분의 속도
    - 각속도 : 회전하려는 성분의 속도

- 속도를 **누적(적분)하면 이동량**
- 로봇은 회전을 하기 때문에 회전에 대한 값을 고려해줌
    - **로봇이 바라보고 있는 방향(헤딩)** 에 따라 이동하는 축이 달라짐

![Odometry 계산 수식](https://i.imgur.com/T2d2plX.png)

- Odometry를 이용해 로봇이 주행할 경로를 만들 수 있음 (계산한 Odometry를 기록하면 경로가 됨)

- Odometry의 취약점
    - 동작하기 위한 조건이 있음 (시작하는 로봇의 위치와 자세 x, y, δ가 경로를 기록했을 떄 로봇의 위치와 자세가 항상 같아야 함)
    - 측정에 있어 오차가 존재 (누적 오차, 회전에 대해 오차가 크게 발생)

- ROS에서 `nav_msgs/Odometry` 메시지 타입 이용
    - 사용해야 하는 메시지 필드는 다음과 같음
    - header의 frame_id: : 기준좌표계의 이름
    - pose : position(위치)과 orientation(쿼터니언)으로 이루어져 있음

### 좌표계
공간상에서 물체의 위치를 표현하는 체계
- **기준 좌표계** : 물체의 위치를 나타낼 때 사용한 좌표계
- 로봇에서는 하나의 좌표계가 아니라 여러 개의 좌표계를 사용
- 기준좌표에 따른 라이다 데이터 표현 방법
    - map을 기준 좌표계로 데이터를 표현해야 전체 맵을 이해하기 쉬움
    - RVIZ는 시각화 툴로 ROS의 좌표계(TF2) 기능을 사용하면 원하는 좌표계를 기준으로 놓고 데이터를 볼 수 있음
    - TF2 튜토리얼을 이용해 실습 진행

### 물체의 자세
기준 좌표계에서 물체가 얼마나 회전되어있는지
- **오일러각**
    - 물체의 자세를 **Roll Pitch Yaw** 3가지로 표현하는 방법
    - 직관적으로 이해하기 쉬움
    - 몇몇 자세를 표현하지 못하는 **짐벌락** (Gimbal Lock) 현상이 있음. ex) pitch = 90°일 때 roll과 yaw가 같은 축이 되어버려서 자유도 하나가 사라짐 ! 로봇 입장에서는 갑자기 orientation 계산이 이상해지고 회전이 튐

- **쿼터니언**
    - 물체의 자세를 **X Y Z W** 4가지 변수를 표현하는 방법
    - 직관적으로 판별하기 어려움
    - 모든 자세를 표현할 수 있으며 빠른 연산처리가 가능하여 **컴퓨터**그래픽에서 주로 사용하는 좌표계 (ROS2도 orientation을 항상 Quaternion으로 저장)

![오일러각과 쿼터니언](https://i.imgur.com/f2wduY7.png)

- 굳이 수식을 변환 수식을 구현할 필요 없이 미리 구현되어있는 `squaternion`이라는 모듈 사용
- **오일러각 → 쿼터니언** 변환 수식
```
from squaternion import Quaternion
from math import pi

roll = 0
pitch = 0
yaw = pi/6

q = Quaternion.from_euler(roll,pitch,yaw)
```

- **쿼터니언 → 오일러각** 변환 수식
```
from squaternion import Quaternion
from math import pi

q_w = 0.9659258
q_x = 0
q_y = 0
q_z = 0.2588190

q = Quaternion(q_w,q_x,q_y,q_z)
roll,pitch,yaw=q.to_euler()
```

- ROS2에서 `nav_msgs/Path` 메시지 타입 이용
    - 사용해야 하는 메시지의 필드는 다음과 같다
    - header의 frame_id : 기준좌표계의 이름
    - poses : 경로점들을 가지고 있는 배열 (경로점들은 pose에서 position과 orientation으로 이루어져 있음)